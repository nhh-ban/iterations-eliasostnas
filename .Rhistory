labs(x = "Sample Size (N)", y = "Standard Deviation") +
ylim(c(0,0.3)) +
theme_minimal()
library(tweedie)
install.packages("tweedie")
library(tweedie)
rtweedie(n = 10, mu = 10000, phi = 1000, power = 1.9)
rtweedie(n = 10, mu = 10000, phi = 1000, power = 1.9)
?function
?function
insurance_claims <- rtweedie(n = 10, mu = 10000, phi = 1000, power = 1.9)
?tweedie
?phi
mean(x)
x <- rtweedie(n = 100000, mu = 10000, phi = 1000, power = 1.9)
mean(x)
N <- 100
true_mu <- 10000
sample <- rtweedie(N, mu = true_mu, phi = 1000, power = 1.9)
t.test(sample, mu = true_mu)
N <- 100
true_mu <- 10000
sample <- rtweedie(N, mu = true_mu, phi = 1000, power = 1.9)
t.test(sample, mu = true_mu)
N <- 100
true_mu <- 10000
sample <- rtweedie(N, mu = true_mu, phi = 1000, power = 1.9)
t.test(sample, mu = true_mu)
N <- 100
true_mu <- 10000
sample <- rtweedie(N, mu = true_mu, phi = 1000, power = 1.9)
t.test(sample, mu = true_mu)
N <- 100
true_mu <- 10000
sample <- rtweedie(N, mu = true_mu, phi = 1000, power = 1.9)
t.test(sample, mu = true_mu)
N <- 100 # Generating sample of 100 insurance claims
true_mu <- 10000 # Sets the true expected value(mean) to 10,000
sample <- rtweedie(N, mu = true_mu, phi = 1000, power = 1.9)
t.test(sample, mu = true_mu) # t-test using mu = 10,000 as null hypothesis
simTweedieTest <- function(N, mu, phi, power) {
result <- rtweedie(N, mu = 10000, phi = 100, power = 1.9)
t.test(result, mu = true.mu)
}
simTweedieTest <- function(N, mu, phi, power) {
result <- rtweedie(N, mu = 10000, phi = 100, power = 1.9)
t.test(result, mu = true.mu)
}
simTweedieTest <- function(N, mu, phi, power) {
test_result <- rtweedie(N, mu = mu, phi = phi, power = power)
t.test(result, mu = 10000)
return(test_result$p.value)
}
simTweedieTest <- function(N, mu, phi, power) {
test_result <- rtweedie(N, mu = mu, phi = phi, power = power)
t.test(result, mu = 10000)
return(test_result$p.value)
}
simTweedieTest(N, 10000, 100, 1.9)
simTweedieTest(N, mu = 10000, phi = 100, power = 1.9)
simTweedieTest <- function(N, mu, phi, power) {
test_result <- rtweedie(N, mu = mu, phi = phi, power = power)
t.test(test_result, mu = 10000)
return(test_result$p.value)
}
simTweedieTest(N, mu = 10000, phi = 100, power = 1.9)
simTweedieTest <- function(N, mu, phi, power) {
test_result <- rtweedie(N, mu = mu, phi = phi, power = power)
t.test(test_result, mu = 10000)
return(test_result)
}
simTweedieTest(N, mu = 10000, phi = 100, power = 1.9)
t.test(sample, mu = true_mu) # t-test using mu = 10,000 as null hypothesis
simTweedieTest <- function(N, mu, phi, power) {
test_result <- rtweedie(N, mu = mu, phi = phi, power = power)
t.test(test_result, mu = 10000)$p.value
return(test_result)
}
simTweedieTest(N, mu = 10000, phi = 100, power = 1.9)
simTweedieTest <- function(N, mu, phi, power) {
test_result <- rtweedie(N, mu = mu, phi = phi, power = power)
p_value <- t.test(test_result, mu = 10000)$p.value
return(test_result)
}
simTweedieTest(N, mu = 10000, phi = 100, power = 1.9)
p_value <- simTweedieTest(N, mu = 10000, phi = 100, power = 1.9)
print(p_value)
mean(p_value)
# Calculate the mean of the p-values
mean_p_value <- mean(p_values)
simTweedieTest <- function(N, mu, phi, power) {
test_result <- rtweedie(N, mu = mu, phi = phi, power = power)
p_value <- t.test(test_result, mu = 10000)$p.value
return(p_value)
}
# Number of times to run the simulation
n <- 100
# Vector to store the p-values
p_values <- numeric(n)
# Perform simulations and store p-values
for (i in 1:n) {
p_values[i] <- simTweedieTest(N, mu = 10000, phi = 100, power = 1.9)
}
# Calculate the mean of the p-values
mean_p_value <- mean(p_values)
# Print the mean p-value
print(mean_p_value)
simTweedieTest <- function(N, mu, phi, power) {
test_result <- rtweedie(N, mu = mu, phi = phi, power = power)
p_value <- t.test(test_result, mu = 10000)$p.value
return(p_value)
}
# Number of times to run the simulation
n <- 100
# Vector to store the p-values
p_values <- numeric(n)
# Perform simulations and store p-values
for (i in 1:n) {
p_values[i] <- simTweedieTest(N, mu = 10000, phi = 100, power = 1.9)
}
# Calculate the mean of the p-values
mean_p_value <- mean(p_values)
# Print the mean p-value
print(mean_p_value)
N <- 100 # Generating sample of 100 insurance claims
true_mu <- 10000 # Sets the true expected value(mean) to 10,000
sample <- rtweedie(N, mu = true_mu, phi = 1000, power = 1.9)
t.test(sample, mu = true_mu) # t-test using mu = 10,000 as null hypothesis
# Reanrranging to a function using N observations
simTweedieTest <- function(N, mu, phi, power) {
test_result <- rtweedie(N, mu = mu, phi = phi, power = power)
p_value <- t.test(test_result, mu = 10000)$p.value
return(test_result)
}
p_value <- simTweedieTest(N, mu = 10000, phi = 100, power = 1.9)
print(p_value)
# Calculate the mean of the p-values
mean_p_value <- mean(p_values)
# Print the mean p-value
print(mean_p_value)
N <- 100 # Generating sample of 100 insurance claims
true_mu <- 10000 # Sets the true expected value(mean) to 10,000
sample <- rtweedie(N, mu = true_mu, phi = 1000, power = 1.9)
t.test(sample, mu = true_mu) # t-test using mu = 10,000 as null hypothesis
# Rearranging to a function using N observations
simTweedieTest <- function(N, mu, phi, power) {
test_result <- rtweedie(N, mu = mu, phi = phi, power = power)
p_value <- t.test(test_result, mu = 10000)$p.value
return(p_value)
}
p_value <- simTweedieTest(N, mu = 10000, phi = 100, power = 1.9)
print(p_value)
t.test(sample, mu = true_mu) # t-test using mu = 10,000 as null hypothesis
standard_dev_sample <- sd(sample_means)
# True population standard deviation (sigma)
true_sigma <- 1  # Replace with the actual population standard deviation
# Print the calculated and true standard deviations
cat("Sample Means Standard Deviation:", standard_dev_sample, "\n")
cat("True Population Standard Deviation:", true_sigma, "\n")
?replicate
MTweedieTests <- function(M, N, alpha) {
p_values <- numeric(M) # Empty vector to store p-values
p_values <- replicate(M, simTweedieTest(N, mu, phi, power))
percentage_below_alpha <- mean(p_values < alpha)
return(percentage_below_alpha)
}
print(percentage)
percentage <- MTweedieTests(M, N, alpha, mu, phi, power)
print(percentage)
MTweedieTests <- function(M, N, alpha, mu, phi, power) {
count_below_alpha <- 0
for (i in 1:M) {
p_value <- simTweedieTest(N)
if (p_value < alpha) {
count_below_alpha <- count_below_alpha + 1
}
}
return(percentage_below_alpha)
}
M <- 100
N <- 100
alpha <- 0.05
percentage <- MTweedieTests(M, N, alpha)
p_value <- simTweedieTest(N, mu = 10000, phi = 100, power = 1.9)
print(p_value)
MTweedieTests <- function(M, N, alpha, mu, phi, power) {
count_below_alpha <- 0
for (i in 1:M) {
p_value <- simTweedieTest(N)
if (p_value < alpha) {
count_below_alpha <- count_below_alpha + 1
}
}
return(percentage_below_alpha)
}
M <- 100
N <- 100
alpha <- 0.05
percentage <- MTweedieTests(M, N, alpha)
power <- 1.9
MTweedieTests <- function(M, N, alpha, mu, phi, power) {
count_below_alpha <- 0
for (i in 1:M) {
p_value <- simTweedieTest(N)
if (p_value < alpha) {
count_below_alpha <- count_below_alpha + 1
}
}
return(percentage_below_alpha)
}
M <- 100
N <- 100
alpha <- 0.05
power <- 1.9
percentage <- MTweedieTests(M, N, alpha)
MTweedieTests <- function(M, N, alpha, mu, phi, power) {
count_below_alpha <- 0
for (i in 1:M) {
p_value <- simTweedieTest(N)
if (p_value < alpha) {
count_below_alpha <- count_below_alpha + 1
}
}
return(percentage_below_alpha)
}
M <- 100
N <- 100
alpha <- 0.05
power <- 1.9
percentage <- MTweedieTests(M, N, alpha, mu, phi, power)
# Task 2:2
# Create function MyTweedieTests that makes M, N and Aplha arguments
# Call simTweedieTest M times with sample size N, then return percentage of tests where p
# is lower than alpha
# hint - make an empty vector size of M, which we fill with p-values for a loop
MTweedieTests <- function(M, N, alpha, mu, phi, power) {
count_below_alpha <- 0
for (i in 1:M) {
p_value <- simTweedieTest(N, mu, phi, power)
if (p_value < alpha) {
count_below_alpha <- count_below_alpha + 1
}
}
return(percentage_below_alpha)
}
M <- 100
N <- 100
alpha <- 0.05
power <- 1.9
percentage <- MTweedieTests(M, N, alpha, mu, phi, power)
# Task 2:2
# Create function MyTweedieTests that makes M, N and Aplha arguments
# Call simTweedieTest M times with sample size N, then return percentage of tests where p
# is lower than alpha
# hint - make an empty vector size of M, which we fill with p-values for a loop
MTweedieTests <- function(M, N, alpha, mu, phi, power) {
count_below_alpha <- 0
for (i in 1:M) {
p_value <- simTweedieTest(N, mu, phi, power)
if (p_value < alpha) {
count_below_alpha <- count_below_alpha + 1
}
}
return(percentage_below_alpha)
}
M <- 100
N <- 100
alpha <- 0.05
mu <- 10000
phi <- 100
power <- 1.9
percentage <- MTweedieTests(M, N, alpha, mu, phi, power)
# Task 2:2
# Create function MyTweedieTests that makes M, N and Aplha arguments
# Call simTweedieTest M times with sample size N, then return percentage of tests where p
# is lower than alpha
# hint - make an empty vector size of M, which we fill with p-values for a loop
MTweedieTests <- function(M, N, alpha, mu, phi, power) {
count_below_alpha <- 0
for (i in 1:M) {
p_value <- simTweedieTest(N, mu, phi, power)
if (p_value < alpha) {
count_below_alpha <- count_below_alpha + 1
}
}
return(count_below_alpha)
}
M <- 100
N <- 100
alpha <- 0.05
mu <- 10000
phi <- 100
power <- 1.9
percentage <- MTweedieTests(M, N, alpha, mu, phi, power)
print(percentage)
print(paste(percentage * 100, "%", sep = ""))
print(paste(percentage, "%", sep = ""))
print(paste(percentage, "%"))
print(paste(percentage,"%"))
?paste
print(percentage,"%")
print(paste((percentage,"%"))
print(paste((percentage,"%"))
print(paste(percentage,"%"))
library(dplyr)
library(ggplot2)
library(tweedie)
print(percentage)
print(percentage)
percentage <- (MTweedieTests(M, N, alpha, mu, phi, power))/100
print(percentage)
print(percentage)
alpha <- 0.05
print(percentage)
df <-
tibble(
N = c(10,100,5000),
M = 100,
share_reject = NA
)
View(df)
df <- tibble(N = c(10, 100, 1000, 5000), M = 100, share_reject = NA)
View(df)
alpha <- 0.05
for (i in 1:nrow(df)) {
N <- df$N[i]
M <- df$M
alpha <- 0.05
for (i in 1:nrow(df)) {
N <- df$N[i]
M <- df$M
alpha <- 0.05
share_reject <- MTweedieTests(M, N, alpha)
df$share_reject[i] <- share_reject
}
View(df)
for (i in 1:nrow(df)) {
N <- df$N[i]
M <- df$M
alpha <- 0.05
share_reject <- MTweedieTests(M, N, alpha)
df$share_reject[i] <- share_reject
}
print(df)
print(df)
View(df)
View(df)
View(df)
View(df)
View(df)
View(df)
View(df)
View(df)
11.1111 * 5
11.1111 * 15
library(dplyr)
library(ggplot2)
library(tweedie)
sim_norm <- function(N, mu = 0, sigma = 1) {
# Generate N random observations from a normal distribution
samples <- rnorm(N, mean = mu, sd = sigma)
# Calculate the mean of the sample
the_mean <- mean(samples)
return(the_mean)
}
sim_norm(N = 10)
sim_norm(N = 10, mu = 15)
# Task 1:2 - create a loop to fill the vector with sample means
M <- 20
sample_means <- rep(NA, M) # Create vector called sample_means containing 20 NA values
for(i in 1:M) { # Create loop for numbers 1-20 in the vector
sample_means[i] <- sim_norm(10) # 10 observations
}
# Task 1:3 - calculate standard deviation of the sample means you just calculated above
standard_dev_sample <- sd(sample_means)
# True population standard deviation (sigma)
true_sigma <- 1  # The actual sd is 1 from the assignment text
# Print the calculated and true standard deviations
cat("Sample Means Standard Deviation:", standard_dev_sample, "\n")
cat("True Population Standard Deviation:", true_sigma, "\n")
# Task 1:4 - create tibble. St_dev no values yet
n <- 200
sigma <- 1
# Create a vector to store sample means
sample_means <- numeric(M)
# Define a sequence of sample sizes from 1 to n
sample_sizes <- 1:n
# Create a tibble to store the results
df <- tibble(
N = sample_sizes,                 # Number of observations (sample sizes)
st_dev = rep(NA, n),              # Initialize st_dev as a vector of NA values
sig = rep(sigma, n),              # Initialize sig with the constant value of sigma
theoretical = rep(NA, n)         # Initialize theoretical as a vector of NA values
)
print(df)
# Calculate sample means and populate the tibble
for (i in 1:n) {
N <- sample_sizes[i]
sample_means <- replicate(M, sim_norm(N = N, sigma = sigma)) # replicate sim_norm function
df$st_dev[i] <- NA #Keep value at NA
df$theoretical[i] <- sigma / sqrt(N) # Theoretical sd is sigma/(sqrt_n)
}
print(df)
# Task 1:5
# Calculate sample means and populate the tibble
for (i in 1:n) {
N <- sample_sizes[i]
sample_means <- replicate(M, sim_norm(N = N, sigma = sigma))
df$st_dev[i] <- sd(sample_means)
df$theoretical[i] <- sigma / sqrt(N)
}
print(df)
# Task 1:6
# Create a ggplot object
# I have to find what geom works best
plot <- ggplot(df, aes(x = N)) +
geom_histogram(aes(y = st_dev, color = "Observed")) +
geom_path(aes(y = theoretical, color = "Theoretical")) +
labs(x = "Sample Size (N)", y = "Standard Deviation") +
ylim(c(0,0.3)) +
theme_minimal()
print(plot)
plot <- ggplot(df, aes(x = N)) +
geom_line(aes(y = st_dev, color = "Observed")) +
geom_line(aes(y = theoretical, color = "Theoretical")) +
labs(x = "Sample Size (N)", y = "Standard Deviation") +
ylim(c(0,0.3)) +
theme_minimal()
print(plot)
# Create a ggplot object
plot <- ggplot(df, aes(x = N)) +
geom_line(aes(y = st_dev, color = "Observed")) +
geom_smooth(aes(y = theoretical, color = "Theoretical")) +
labs(x = "Sample Size (N)", y = "Standard Deviation") +
ylim(c(0,0.3)) +
theme_minimal()
print(plot)
setwd("/Users/eliasostnaes/Documents/iterations-eliasostnas")
library(httr)
library(jsonlite)
library(ggplot2)
library(DescTools)
library(tidyverse)
library(magrittr)
library(rlang)
library(lubridate)
library(anytime)
library(readr)
library(yaml)
#### 1: Beginning of script
# Load function for posting GQL-queries and retrieving data:
source("functions/GQL_function.r")
# The URL we will use is stored below:
configs <-
read_yaml("vegvesen_configs.yml") # reads the api link from the assignment
gql_metadata_qry <- read_file("gql-queries/station_metadata.gql")
# Let's try submitting the query:
stations_metadata <-
GQL(
query=gql_metadata_qry,
.url = configs$vegvesen_url
)
#### 2: Transforming metadata to a tibble, converting latestData to UTC format
source("functions/data_transformations.r") # calling function from data_transformations.R
stations_metadata_df <-
stations_metadata %>% # retrieve data from stations_metadata and call it stations_metadata_df
transform_metadata_to_df() # using this function for stations_metadata to create stations_metadata_df
head(stations_metadata_df) # to show tibble
#### 3: Testing metadata
source("functions/data_tests.r") # retrieving functions from fie data_sets.r in the functions folder
test_stations_metadata(stations_metadata_df) # runs the function test_stations_metadata
# from the stations_metadata_df dataset
### 4.b: call vol_cry function
source("gql-queries/vol_qry.r")
GQL(
vol_qry(
id=stations_metadata_df$id[1],
from=to_iso8601(stations_metadata_df$latestData[1],-4),
to=to_iso8601(stations_metadata_df$latestData[1],0)
),
.url = configs$vegvesen_url
)
### 5: Final volume query:
stations_metadata_df %>%
filter(latestData > Sys.Date() - days(7)) %>%
sample_n(1) %$% # showing results from one random station
vol_qry(
id = id,
from = to_iso8601(latestData, -4),
to = to_iso8601(latestData, 0)
) %>%
GQL(., .url = configs$vegvesen_url) %>%
transform_volumes() %>% #line 62
ggplot(aes(x=from, y=volume)) +
geom_line() +
theme_classic()
# Problem 6 - making the plot prettier
stations_metadata_df %>%
filter(latestData > Sys.Date() - days(7)) %>%
sample_n(1) -> selected_station
data_for_plot <- selected_station %$% vol_qry(
id = id,
from = to_iso8601(latestData, -4),
to = to_iso8601(latestData, 0)
) %>%
GQL(., .url = configs$vegvesen_url) %>%
transform_volumes(station_name = selected_station$name[1])
data_for_plot %>%
ggplot(aes(x=from, y=volume, color=station)) +
geom_line() +
labs(color="Traffic Station") +
theme_classic()
